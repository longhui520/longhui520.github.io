(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{378:function(t,e,a){"use strict";a.r(e);var s=a(42),v=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" vue")]),t._v(" "),a("h2",{attrs:{id:"vue使用技巧"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue使用技巧"}},[t._v("#")]),t._v(" vue使用技巧")]),t._v(" "),a("h3",{attrs:{id:"透传插槽-vue2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#透传插槽-vue2"}},[t._v("#")]),t._v(" 透传插槽(vue2+)")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(' <slot v-for="(_, name) in $slots" :name="name" :slot="name" />\n  <template v-for="(_, name) in $scopedSlots" :slot="name" slot-scope="slotData">\n    <slot :name="name" v-bind="slotData" />\n  </template>\n')])])]),a("h2",{attrs:{id:"vue性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue性能优化"}},[t._v("#")]),t._v(" vue性能优化")]),t._v(" "),a("ul",[a("li",[t._v("展示类组件使用函数式组件\n当一个组件只依赖父组件传入值的时候，并且没有自己的状态和事件时，特别时候适合函数式组件。\nvue的函数式组件因为你没有正常组件的状态，事件，生命构造，初始渲染会更快。")]),t._v(" "),a("li",[t._v("子组件拆分\n如果在模板插值中使用了函数调用，那么组件的每次重新渲染都会重新调用函数，如果吧这部分拆分放入一个子组件中运算，这个函数调用只会执行一次。\n计算属性可以优化这个")]),t._v(" "),a("li",[t._v("局部变量\n在代码中每次通过this获取响应式数据都会触发这个数据的get钩子，通过保存获取的变量避免多触发响应式数据的get钩子")]),t._v(" "),a("li",[t._v("v-show和v-if\nv-if作用在子组件上时 切换会导致子组件重新开始渲染\nV-show 只是dom的显示隐藏切换，性能更好")]),t._v(" "),a("li",[t._v("keep-alive\n可以保存组件的状态，下次切换回来不用重新渲染组件")]),t._v(" "),a("li",[t._v("延迟加载子组件\n大量加载子组件会暂用大量时间导致渲染卡顿，如果只在浏览器的每一帧中加载少量组件，子组件渐进显示出来。")]),t._v(" "),a("li",[t._v("时间切片\n大量添加数据时，分批添加")]),t._v(" "),a("li",[t._v("非响应式数据\n不需要响应式的数据，可以设置成非响应式。")]),t._v(" "),a("li",[t._v("虚拟滚动")]),t._v(" "),a("li",[t._v("总结：减少不必要的渲染，函数计算缓存，组件分片渲染。")])])])}),[],!1,null,null,null);e.default=v.exports}}]);