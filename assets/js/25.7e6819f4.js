(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{375:function(v,t,e){"use strict";e.r(t);var n=e(42),_=Object(n.a)({},(function(){var v=this,t=v.$createElement,e=v._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[v._v("#")]),v._v(" vue")]),v._v(" "),e("h2",{attrs:{id:"vue性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue性能优化"}},[v._v("#")]),v._v(" vue性能优化")]),v._v(" "),e("ul",[e("li",[v._v("展示类组件使用函数式组件\n当一个组件只依赖父组件传入值的时候，并且没有自己的状态和事件时，特别时候适合函数式组件。\nvue的函数式组件因为你没有正常组件的状态，事件，生命构造，初始渲染会更快。")]),v._v(" "),e("li",[v._v("子组件拆分\n如果在模板插值中使用了函数调用，那么组件的每次重新渲染都会重新调用函数，如果吧这部分拆分放入一个子组件中运算，这个函数调用只会执行一次。\n计算属性可以优化这个")]),v._v(" "),e("li",[v._v("局部变量\n在代码中每次通过this获取响应式数据都会触发这个数据的get钩子，通过保存获取的变量避免多触发响应式数据的get钩子")]),v._v(" "),e("li",[v._v("v-show和v-if\nv-if作用在子组件上时 切换会导致子组件重新开始渲染\nV-show 只是dom的显示隐藏切换，性能更好")]),v._v(" "),e("li",[v._v("keep-alive\n可以保存组件的状态，下次切换回来不用重新渲染组件")]),v._v(" "),e("li",[v._v("延迟加载子组件\n大量加载子组件会暂用大量时间导致渲染卡顿，如果只在浏览器的每一帧中加载少量组件，子组件渐进显示出来。")]),v._v(" "),e("li",[v._v("时间切片\n大量添加数据时，分批添加")]),v._v(" "),e("li",[v._v("非响应式数据\n不需要响应式的数据，可以设置成非响应式。")]),v._v(" "),e("li",[v._v("虚拟滚动")]),v._v(" "),e("li",[v._v("总结：减少不必要的渲染，函数计算缓存，组件分片渲染。")])])])}),[],!1,null,null,null);t.default=_.exports}}]);